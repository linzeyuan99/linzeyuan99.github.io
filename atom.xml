<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>狗&amp;窝</title>
  
  <subtitle>Share~</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-31T04:50:45.010Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Jerry_lin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/31/Hexo%20+%20github%E8%B8%A9%E5%9D%91/"/>
    <id>http://example.com/2021/10/31/Hexo%20+%20github%E8%B8%A9%E5%9D%91/</id>
    <published>2021-10-31T04:59:46.425Z</published>
    <updated>2021-10-31T04:50:45.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-github踩坑"><a href="#Hexo-github踩坑" class="headerlink" title="Hexo + github踩坑"></a>Hexo + github踩坑</h1><p>早上起来弄到现在六个小时左右，终于完成了个人网站的初始化。</p><p>直接说吧 就在hexo init 和 hexo d这里踩坑</p><p>首先前者 hexo init 要注意是把nodejs更新到最新版本<br>hexo d 的话 要先获取ssh公钥，怎么获取自行百度或者csdn看 只需要一串命令即可</p><p>完成这一步之后 会经常撞到 网络不稳定导致各种failed的原因<br>在这里希望大家的配置能这样设置：</p><p>不建议用https  转用ssh</p><p>deploy:<br>type: git<br>repository:<br>github: <a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#x63;&#111;&#109;">&#x67;&#105;&#116;&#64;&#103;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#x63;&#111;&#109;</a>:你的名字/你的名字.github.io.git<br>branch: main或者master  #这里哪个可以用哪个，有的博主说更新了必须用main</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo-github踩坑&quot;&gt;&lt;a href=&quot;#Hexo-github踩坑&quot; class=&quot;headerlink&quot; title=&quot;Hexo + github踩坑&quot;&gt;&lt;/a&gt;Hexo + github踩坑&lt;/h1&gt;&lt;p&gt;早上起来弄到现在六个小时左右，终于完成了个人</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/31/HashMap%E5%92%8CArrayList%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2021/10/31/HashMap%E5%92%8CArrayList%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81/</id>
    <published>2021-10-31T04:59:46.421Z</published>
    <updated>2021-10-31T04:58:41.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-HashMap一些底层方法理解"><a href="#1-HashMap一些底层方法理解" class="headerlink" title="1.HashMap一些底层方法理解"></a>1.HashMap一些底层方法理解</h1><h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2><p>仅适合看过源码的朋友~~小总结</p><p>通过观察源码我们可以发现，remove方法里面有一个removeNode方法，基本整个逻辑都是在<br>这里面进行的，首先判断这个表不为空并且下标有值，这个判断和getNode方法的第一层if是<br>一个意思，否则的话条件不成立就直接返回null，成立的话就进入以下逻辑：<br>第一种情况就是说该桶位的key和传进来的key是相等的，并且是一个桶位就直接remove删除<br>第二种情况就是说next不等于null就代表后面还有值，有哈希碰撞那么还需要判断类型，如果<br>说是该节点是树类的话，就调用树的getTreeNode方法，否则就是链表就挨个遍历然后删即即可</p><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p>仅适合看过源码的朋友~~</p><p>通过观察源码可以发现，get方法里面有一个getNode()方法，那么这个getNode方法就是整个<br>核心部分，getNode方法里传递的参数是hash和key，首先if判断这个表是否为空，长度是否大<br>于0，然后当前下标的值不能是null，否则就返回null，有值的话就进入判断，3钟情况：<br>第一种情况就是说，当前桶位就一个元素，那获取到之后就直接返回<br>第二种情况就是说，当前桶位不止一个元素，next不等于null就代表有哈希碰撞了并且是这个<br>节点属于红黑树，那么就调用这个树的获取方法去进行<br>第三种情况就是说，也是桶位不止一个元素，桶位形成链表的情况，这种情况就也很简单，判断<br>key相等然后返回就行了</p><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>仅适合看过源码的朋友们~~</p><p>首先关于这个put方法，通过源码分析我们可以发现，put方法传参是key，value。那么其实<br>里面有一个方法putVal()，hash就是低16位与高16位异或得到。</p><p>那么我们来看putVal，通过观察源码我们可以分析大概为四种情况：<br>1.slot为空 我们直接通过寻址算法(table.length - 1 &amp; hash) 找到数组下标<br>然后newNode()包装完之后丢进下标就可以了<br>2.slot不为空的情况 还未被链化，需要对比一下，对比这个key和put进来的key是否一致，<br>如果一致的话就做一个替换操作，如果不一致的话就是一波hash冲突了，那么如果这种情况<br>的话，这种情况就用尾插的方式插入进链表里面去<br>3.这种情况就已经链化了，跟第二种情况相似，需要我们去进行对比一下，对比进来这个key<br>和put进来的key是否一致，一致的话就进行替换操作，如果不一致的话用尾插法的形式给它<br>插到链表尾部就好了，这个还没完，如果这个时候就要去比较树化阈值，如果达到这个树化<br>阈值的话，就需要调用这个树化方法，这个树化操作都在该方法里完成<br>4.就是很严重的情况了，那个链表已经转成红黑树了</p><h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><p>仅适合看过源码的朋友们~~</p><p>还是以jdk1.8为例，通过源码观察，我们可以发现这个resize方法有一个注解，这个注解上下<br>划为两个区域，(那么其实这个注解就不做过多的解释了，这个注解叫做supperwarnings，意<br>思大概就是不让编译器起到警告信息的作用)，那说回来是这样子的，注解的上半部分就是开了<br>个newCap和newThr(新数组长度，新的扩容阈值)，newCap就是新数组table长度，做一系列<br>判断后啊他就让oldCap左移1位就是乘2的意思，新的扩容阈值就是让它去做一个新数组长度去<br>乘以这个负载因子得到，里面还有些大小判断就不细讲了。</p><p>那么到这个核心就是注解的下半部分代码，通过源码我们可以观察到他扩容是通过一个一个迭<br>代，用到的是一个for循环，循环次数是oldCap也就是老数组的大小，在这个循环里面有许多<br>的if和else if的判断，总的来说分位四种情况：<br>1.slot是null<br>在说2和3的情况下先说一下源码里面有提到loHead、loTail、hiHead、hiTail<br>分别对应的是：低位链表头、低位链表尾、高位链表头、高位链表尾<br>2.slot存储的是Node，还没有链化<br>3.slot存储是Node,已经链化的情况<br>4.存储的是了一个红黑树根节点TreeNode对象</p><p>迁移的时候发现这个slot存储这个节点是null的时候，说明没有产生hash冲突就直接通过<br>寻址算法(e.hash&amp;newCap-1)得到下标后，根据新表计算出来的下标直接迁移进去就好了。<br>然后就是说如果这个node.next不是null的情况说明发生过hash冲突，需要分位高位链、和<br>低位链。简单说这个老表里这个桶位已经链化了，链表的所有hash字段转为二进制后低位都<br>是相同的，低位就是table.length - 1转化的二进制的有效位，打比方 16 - 1 -》 15的<br>二进制1111高位是第5位是0，但不一定所有高位都是0有可能是1,低位链因为高位是0所以迁<br>移到node新表的时候，slot下标和老表的下标是一样的，如果是高位链的话迁移到新表的下标<br>就是老表位置+老表的长度，比如老表大小是16然后下标是8，16+8就是24，下标24的桶位</p><h1 id="2-Arraylist一些源码"><a href="#2-Arraylist一些源码" class="headerlink" title="2.Arraylist一些源码"></a>2.Arraylist一些源码</h1><p><img src="D:\Typora\pictures\image-20211031125723089.png" alt="image-20211031125723089"></p><p><img src="D:\Typora\pictures\image-20211031125741242.png" alt="image-20211031125741242"><img src="D:\Typora\pictures\image-20211031125755304.png" alt="image-20211031125755304"></p><p><img src="D:\Typora\pictures\image-20211031125810401.png" alt="image-20211031125810401"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-HashMap一些底层方法理解&quot;&gt;&lt;a href=&quot;#1-HashMap一些底层方法理解&quot; class=&quot;headerlink&quot; title=&quot;1.HashMap一些底层方法理解&quot;&gt;&lt;/a&gt;1.HashMap一些底层方法理解&lt;/h1&gt;&lt;h2 id=&quot;remov</summary>
      
    
    
    
    
  </entry>
  
</feed>
